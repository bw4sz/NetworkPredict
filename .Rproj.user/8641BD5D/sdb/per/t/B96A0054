{
    "contents" : "#extract and create a dataframe of posteriors\n\nextract_par<-function(x,data=obs,Bird=\"Bird\",Plant=\"Plant\"){\n  #extract desired info from the models\n  parsO<-melt(x$BUGSoutput$sims.array)\n  colnames(parsO)<-c(\"Draw\",\"Chain\",\"parameter\",\"estimate\")\n  \n  #label species and plants\n  l<-levels(parsO$parameter)\n  \n  #parameters to save\n  totrack<-x$parameters.to.save\n  \n  #assign species index to ragged frame.\n  sp_pl<-data.frame(parameter=l,species=as.numeric(str_match(l,pattern=\"\\\\[(\\\\d+)]\")[,2]),par=str_extract(l,\"\\\\w+\"))\n  \n  #correct N samples\n  #i<-sp_pl$par %in% \"ynew\"\n  \n  #Species\n  #sp_pl[i,][,\"species\"]<-data[as.numeric(str_match(sp_pl[i,][,\"parameter\"],pattern=\"\\\\[(\\\\d+)]\")[,2]),Bird]\n  \n  #Plant\n  #add a NA plant columns\n  #sp_pl$plant<-NA\n  #sp_pl[i,][,\"plant\"]<-\n   # data[as.numeric(str_match(sp_pl[i,][,\"parameter\"],pattern=\"\\\\[(\\\\d+)]\")[,2]),Plant]\n  \n  #merge levels\n  pars<-merge(parsO,sp_pl)\n  \n  #take out deviance\n  pars<-pars[!pars$par %in% \"deviance\",]\n  return(pars)\n}\n#fits a chisquared residual for a given poisson function\n\ntrajState<-function(alpha,beta,x,observed){\n  \n  #Bind together\n  fdat<-data.frame(alpha=alpha,beta=beta)\n  \n  #fit regression for each input estimate\n  sampletraj<-list()\n  for (s in 1:nrow(fdat)){\n    a<-fdat$alpha[s]\n    b<-fdat$beta[s]\n    yp=inv.logit(a + b*x$value)\n    \n    #compute pred value\n    state<-data.frame(x,State=rpois(length(yp),yp))\n    \n    #merge with observed state\n    mstate<-merge(state,observed,by=c(\"Bird\",\"Plant\"))\n    \n    #Compute chisquared\n    csq<-sum((mstate$Y-mstate$State)^2/(mstate$State+0.5))\n    \n    sampletraj[[s]]<-csq\n  }\n  \n  #return as a vector\n  return(unlist(sampletraj))\n}\n\n#sample trajectory for a given posterior\ntrajF<-function(alpha,beta1,beta2,beta3,trait,resources){\n  g<-data.frame(alpha,beta1,beta2,beta3)\n  \n  #label rows\n  g$id<-1:nrow(g)\n  \n  sampletraj<-g %>% group_by(id) %>% do(traj(.$alpha,.$beta1,trait=trait,resources,.$beta2,.$beta3)) %>% group_by(trait) %>% summarize(mean=mean(y),lower=quantile(y,0.05),upper=quantile(y,0.95))\n  return(sampletraj)\n}\n\n#sample trajectory for a given posterior using quantile or hdi interval\ntraj<-function(alpha,beta1,beta2,beta3,trait,resources){\n\n    #fit regression for each input estimate\n    \n    v=inv.logit(alpha + beta1 * trait + beta2 * resources + beta3 * trait*resources)\n    \n    sampletraj<-data.frame(trait=trait,y=as.numeric(v))\n  \n  #Compute CI intervals\n  return(sampletraj)\n}\n\n#sample trajectory for a given posterior using quantile or hdi interval\ntrajLog<-function(alpha,beta1,beta2,beta3,x,resources,type='quantile'){\n  indat<-data.frame(alpha,beta1,beta2,beta3)\n  \n  #fit regression for each input estimate\n  sampletraj<-list()\n  \n  for (y in 1:nrow(indat)){\n    v=inv.logit(indat$alpha[y] + indat$beta1[y] * x + indat$beta2[y] * resources + indat$beta3[y] * x*resources)\n    \n    sampletraj[[y]]<-data.frame(x=as.numeric(x),y=as.numeric(v))\n  }\n  \n  sample_all<-rbind_all(sampletraj)\n  \n  #Compute CI intervals\n  if(type=='quantile'){\n    predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025,na.rm=T),upper=quantile(y,0.975,na.rm=T),mean=mean(y,na.rm=T))\n  }\n  if(type=='hdi'){\n    predy<-group_by(sample_all,x) %>% summarise(lower=hdi(y)[[1]],upper=hdi(y)[[2]],mean=mean(y,na.rm=T))\n  }\n  return(predy)\n}\n\n#predicted y for logistic\ntrajLogistic<-function(alpha,beta1,beta2,beta3,x,resources){\n  indat<-data.frame(alpha,beta1,beta2,beta3)\n  \n  #fit regression for each input estimate\n  sampletraj<-list()\n  \n  for (y in 1:nrow(indat)){\n    v=inv.logit(indat$alpha[y] + indat$beta1[y] * x + indat$beta2[y] * resources + indat$beta3[y] * x*resources)\n    \n    sampletraj[[y]]<-data.frame(x=as.numeric(x),y=as.numeric(v))\n  }\n  \n  sample_all<-rbind_all(sampletraj)\n  \n  #Compute CI intervals\n  predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025,na.rm=T),upper=quantile(y,0.975,na.rm=T),mean=mean(y,na.rm=T))\n}\n\n#calculate poisson interactions\n\nintF<-function(alpha,beta1,beta2,beta3,x,resources){\n  indat<-data.frame(alpha,beta1,beta2,beta3)\n  \n  #fit regression for each input estimate\n  sampletraj<-list()\n  \n  for (y in 1:nrow(indat)){\n    v=indat$beta2[y] + indat$beta3[y]  * x\n    sampletraj[[y]]<-data.frame(x=as.numeric(x),y=as.numeric(v))\n  }\n  \n  sample_all<-rbind_all(sampletraj)\n  \n  #Compute CI intervals\n  predy<-group_by(sample_all,x) %>% summarise(lower=quantile(y,0.025,na.rm=T),upper=quantile(y,0.975,na.rm=T),mean=mean(y,na.rm=T))\n  return(predy)\n}\n\n#plots\n#converge of chains\nchainplot<-function(pars,param,title){\n  ggplot(pars[pars$par %in% param,],aes(x=Draw,y=estimate,col=as.factor(Chain))) + geom_line() + facet_wrap(~species,scale=\"free\") + theme_bw() + labs(col=\"Chain\") + ggtitle(title)  \n}\n\n#posteriors\ntracegplot<-function(pars,param,title){\n  ggplot(pars[pars$par %in% param,],aes(x=estimate)) + geom_histogram() + ggtitle(\"Estimate of Intercept\") + theme_bw() + ggtitle(title)\n}\n\n\n",
    "created" : 1466778362730.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3060532702",
    "id" : "B96A0054",
    "lastKnownWriteTime" : 1466970014,
    "path" : "~/NetworkPredict/Bayesian/BayesFunctions.R",
    "project_path" : "Bayesian/BayesFunctions.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}